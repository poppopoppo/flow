⊗ § ¶ ∀ ' " ' ` ≃ ≒ ◃ ∅ ∠ ∏ ∐ ⟦ ⟧ ∇ ∆ ℤ { } » « ∎ ⊢ ¦ ◂ ⁅ ⁆ ℾ % ⅁ ℚ ℕ ℤ ¬
! $ ? & ( ) ^ ~ | @ _ < > , : ; ◤ ◣ ‹ › \ / = [ ] - + * ↓ ↑ → .

'\"' (([^ '\"']|"\\\"")* as lxm) '\"' ; string
";" [^ '\n']*  ; line comment
".;" (_)* ";."  ; block comment
§  ; global entry
§§ ; module entry
§§. ; module end
¶ ; type entry
\  ; dependent type
∀ ; for all
' ; meta symbol
≃ ; type definition
==  ; macro definitino
~ ; let
» ; arrow
↑ ; coproduct injection
↓ ; product choice
(('|')+ as lxm) » ; code in
» ; code out
⊢ ; hom
(* ⋎ ⋏ *)
? ; exception
: ; type annotation
| ; separation
∠  ; angle operator
[ ; left bracket
] ; right bracket
^ ; code concatenation
¦ ; horizontal bar
∐ ; coproduct
∏ ; product
∎ ; eop
∇ ; coproduct end
∆ ; product end
≒ ; global entry definitino
` ; type annotation indicator
// ; cast operator
_ ; wild card symbol
{ ; left record bracket
} ; right record bracket
⁅ ; left horizontal bracket
⁆ ; right record bracket
⟦ ; left list bracket
⟧ ; right list bracket
‹ ; left option bracket
› ; right option bracket
& ; signature initializer
# ; vector initializer
% ; finite type definition
( ; left parenthesis
) ; right parenthesis
= ; equality operator
! ; level operator
◂ ; application
◃ ; projection
ℤ ; integer type
pℤ  ; polymophic ℤ
ℕ ; natural number type
ℾ ; string type
⅁ ; grammer type
⇑ ; grammer type injection
¬ ; not
+ ; plus
* ; multiple  ⸢f⸥
- ; minus
, ; comma
$ (("\'")*   ; roots
@ (("\'")*  ; fix ((a'→b')→(a'→b'))→(a'→b')
? ; self
¡ ; exception
◂'  ; eval operator
  +< ; ℕ  plus
*<  ; ℕ multiple
-<  ; ℕ minus
´ ; char
° ; IO


\x y z → (x◂z)◂(y◂z)
A B C
(C→X) (C→Y) C

(A◂C)◂(B◂C)
((C→X)◂C)◂((C→Y)◂C)
((C→((C→Y)◂C))◂C)◂((C→Y)◂C)


(x◂z)◂(y◂z)
([X:x\x]◂[Z:z\z])◂([Y:y\y]◂[Z:z\z])
([X0→X1:x\x]◂[Z:z\z])◂([Y0→Y1:y\y]◂[Z:z\z])
([Z→X1:x\x]◂[Z:z\z])◂([Z→Y1:y\y]◂[Z:z\z])
[Z→X1:x,Z:z,X1:t0\t0]◂[Z→Y1:y,Z:z,Y1:t1\t1]

X:x,Y:y,Z:z \ (<X>◂<Z>)◂(<Y>◂<Z>)
(<X0→X1>◂<Z>)◂(<Y0→Y1>◂<Z>)
(<Z→)

¶ tm ≃
  ∐ ! & : p
  ∐ ! & : x
  ∐ ! ⟦tm⟧ : f
~ : { tm tm } → (‹tm›◃&)
[t0',t1',t2' ≃ ↑[∅,∅,a'],b',ℤ]∀ t0'

{ : a∀ a'→rcd == rcd
{◂a0'◂a1'◂} ; close record
{◂a0'◂b9'◂<}  ; open record polymorphic
{◂a0'◂b9'◂c'◂d'◂}
{ a b c d e } == (a*(b*(c*(d*(e*rcd_end))))
{ a b c <} == (a*(b*(c*d')))
{ { x <} { a b } c {} } : $◃0 { 3 4 } "re" {}
{◂(a*b)
! { t0' t1' ℤ <} ⊢ ℤ : $◃2 + 5
∎§∆§∎
(p◂&)◂(v◂&)◂(p◂&) ~ (p◂&)
tm=(tm→tm)
p : &→(tm→tm)
#[

nash equibulium , unification , prolog 
