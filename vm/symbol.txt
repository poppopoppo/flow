⊗ § ¶ ∀ ' " ' ` ≃ ≒ ◃ ∅ ∠ ∏ ∐ ⟦ ⟧ ∇ ∆ ℤ { } » « ∎ ⊢ ¦ ◂ ⁅ ⁆ ℾ % ⅁ ℚ ℕ ℤ ¬
! $ ? & ( ) ^ ~ | @ _ < > , : ; ◤ ◣ ‹ › \ / = [ ] - + * ↓ ↑ → .

'\"' (([^ '\"']|"\\\"")* as lxm) '\"' ; string
";" [^ '\n']*  ; line comment
".;" (_)* ";."  ; block comment
§  ; global entry
§§ ; module entry
§§. ; module end
¶ ; type entry
\  ; dependent type
∀ ; for all
' ; meta symbol
≃ ; type definition
==  ; macro definitino
~ ; let
» ; arrow
↑ ; coproduct injection
↓ ; product choice
(('|')+ as lxm) » ; code in
» ; code out
⊢ ; hom
(* ⋎ ⋏ *)
? ; exception
: ; type annotation
| ; separation
∠  ; angle operator
[ ; left bracket
] ; right bracket
^ ; code concatenation
¦ ; horizontal bar
∐ ; coproduct
∏ ; product
∎ ; eop
∇ ; coproduct end
∆ ; product end
≒ ; global entry definitino
` ; type annotation indicator
// ; cast operator
_ ; wild card symbol
{ ; left record bracket
} ; right record bracket
⁅ ; left horizontal bracket
⁆ ; right record bracket
⟦ ; left list bracket
⟧ ; right list bracket
‹ ; left option bracket
› ; right option bracket
& ; signature initializer
# ; vector initializer
% ; finite type definition
( ; left parenthesis
) ; right parenthesis
= ; equality operator
! ; level operator
◂ ; application
◃ ; projection
ℤ ; integer type
pℤ  ; polymophic ℤ
ℕ ; natural number type
ℾ ; string type
⅁ ; grammer type
⇑ ; grammer type injection
¬ ; not
+ ; plus
* ; multiple  ⸢f⸥
- ; minus
, ; comma
$ (("\'")*   ; roots
@ (("\'")*  ; fix ((a'→b')→(a'→b'))→(a'→b')
? ; self
¡ ; exception
◂'  ; eval operator
  +< ; ℕ  plus
*<  ; ℕ multiple
-<  ; ℕ minus
´ ; char
° ; IO


\x y z → (x◂z)◂(y◂z)
A B C
(C→X) (C→Y) C

(A◂C)◂(B◂C)
((C→X)◂C)◂((C→Y)◂C)
((C→((C→Y)◂C))◂C)◂((C→Y)◂C)


(x◂z)◂(y◂z)
([X:x\x]◂[Z:z\z])◂([Y:y\y]◂[Z:z\z])
([X0→X1:x\x]◂[Z:z\z])◂([Y0→Y1:y\y]◂[Z:z\z])
([Z→X1:x\x]◂[Z:z\z])◂([Z→Y1:y\y]◂[Z:z\z])
[Z→X1:x,Z:z,X1:t0\t0]◂[Z→Y1:y,Z:z,Y1:t1\t1]

X:x,Y:y,Z:z \ (<X>◂<Z>)◂(<Y>◂<Z>)
(<X0→X1>◂<Z>)◂(<Y0→Y1>◂<Z>)
(<Z→)

¶ tm ≃
  ∐ ! & : p
  ∐ ! & : x
  ∐ ! ⟦tm⟧ : f
~ : { tm tm } → (‹tm›◃&)
[t0',t1',t2' ≃ ↑[∅,∅,a'],b',ℤ]∀ t0'

{ : a∀ a'→rcd == rcd
{◂a0'◂a1'◂} ; close record
{◂a0'◂b9'◂<}  ; open record polymorphic
{◂a0'◂b9'◂c'◂d'◂}
{ a b c d e } == (a*(b*(c*(d*(e*rcd_end))))
{ a b c <} == (a*(b*(c*d')))
{ { x <} { a b } c {} } : $◃0 { 3 4 } "re" {}
{◂(a*b)
! { t0' t1' ℤ <} ⊢ ℤ : $◃2 + 5
∎§∆§∎
(p◂&)◂(v◂&)◂(p◂&) ~ (p◂&)
tm=(tm→tm)
p : &→(tm→tm)
#[
nash equiblium , unification , prolog

» add : x ~ y z
» rpc : w0 w1 ~ x
» mul : q ~ w0 w1
» app : y ~ f x

first order environment
first order while-loop
» hf oije
  ¬|» feoijf
  » oijef
  » b oiejf ∎
»
»> x~$ y~z'
»>

horizontal while
» ofie oijf ew2 3 4 ¬⁅ 0 1 2 3
  » 4 5 3*2 +[3,3] {}
  » oief ∎

  » "test" +[0,"hoge"]
  » f 3 ∎

  »　+[1 0,"foo"] +[1 1,"hoo"]
  » t 10 ∎
⁆
  +a ⊢ b c d
  +a +b +c ⊢ d
» cmd o0 o1 .. on : s0 s1 .. sn ⊢ d0 .. dm
» r0 r1 .. rn ∎

⸡⸡⸠|||»»»⁅⁆⁅‹›⸡

¶ reg ≃ ∐ ! & : reg
¶ plc ≃ ∐ ! & : plc
§§ vm2
‹tkn›◃reg ; register space
op◃plc ; operand space
¶ op ≃ ∐ ! ⟦reg⟧ : ret ∐ ⟦reg] ⟦reg⟧ plc : op
§§.

§§ vm3
‹tkn›◃(dℤ◂n')
op◃(dℤ◂n')
§§.

{> `ℤ:x `ℤ:y `Z:z }
x a ∀ {> `(x'→a'→a'):f `a':init `⟦x'⟧:data <}→a' : Lst.fld


Heap | Reg
infinite | finite
Stack | Hd


Heap | Reg | Stack
    agl spt cns inj | r0 r1 r2 .. rN | call ret

Gen-Stack | Reg | Call-Stack
Vct         |   evo
           \/

A◃B      {}◃&
⊵ : A◃B → { B A } → { A◃B bit }
⊵| : A◃B → B → { A◃B bit }

◃' : A◃B → B → ‹A›
◃| : A◃B → B →
|◃ : A◃B → B →

⊵ : A◃B → { B A } → { A◃B ‹A› }
⊵* : A◃B → { B A } → A◃B
⊵+ : A◃B → { B A } → A◃B
⊵| : A◃B → B → { A◃B ‹A› }
|⊵ : A◃B → B → { A◃B ‹A› }
¬⊵ : A◃B → { B A } → { A◃B ‹A› }
