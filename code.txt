
§ frac_m : r x ⊢ y »»
    § @r ⊢ +r0 +b » $0 $0
    OBS b
    | § @x ⊢ @y » $0
    | § r0 @x ⊢ +r1 +x0 » ($0 + -1) ($1 * $0)
      § r1 x0 ⊢ @y » #frac_m
§ frac_m ~ int:R int:X ⊢ int:Y »»
    ¶ @R ⊢ +R0 +B » $0 $0
    ∠ B @X R0
      | @Y » $1
      | +R1 +X0 » ($2 + -1) ($1 * $2)
        ¶ R1 X0 ⊢ @Y » #frac_m

|
§ frac_m ~ int:R int:X ⊢ int:Y »»
    ¶ @R ⊢ +R0 +B » $0 ($0 + -1)
    ∠ B @X R0 ⊢ @Y
      | X ⊢ @Y » $0
      | R0 X ⊢ +R1 +X0 » ($2 + -1) ($1 * $2)
        ¶ R1 X0 ⊢ @Y » #frac_m

§ frac : r ⊢ y »»
  §< @r +x ⊢ @y » #fram_m
    § ⊢ x » 1
    >§
§ frac_r ~ int:X ⊢ int:Y »
  § @X ⊢ +X0 +B » $0 $0
  OBS B
  | § ⊢ @Y » 1
  | § X0 ⊢ +X1 +X2 » $0 ($0 + -1)
    §< X1 +F ⊢ @Y » ($0 * $1)
       § X2 ⊢ F » #frac_r
       >§

§ frac_r ~ int:X ⊢ int:Y »»
  ¶ X ⊢ +X0 +B » $0 $0
  ∠ B X0 ⊢ Y
    | ¶ ⊢ Y » 1
    | ¶ X0 ⊢ +X1 +X2 » $0 ($0 + -1)
      ¶< X1 +F ⊢ @Y » ($0 * $1)
        § X2 ⊢ F »»
          ¶ X2 ⊢ F » #frac_r
        >¶

§ frac_r ~ ℤ:X ⊢ ℤ:Y »»
  ∎ ▼X ⊢ +X0 +B » $0 $0
  ∠ B X0
    | ▲Y » 1
   >| +X1 +X2 » $X0 ($X0 + -1)
      ∎< X1 +F ⊢ ▲Y » ($0 * $1)
        >∎ X2 ⊢ F » #frac_r


§ x.f : y z ⊢ q

∠ frac_r_b ~ (f ~ ℤ ⊢ ℤ) . ℤ:B ℤ:X ⊢ ℤ:Y
»|
  ∎ ⊢ Y » 1
»|
  ∎ X ⊢ +X1 +X2 » $X ($X + -1)
  ∎ X1 +F ⊢ Y » ($X1 * $F)
    ∎ X2 ⊢ F » #f

§ @ frac_r ~ int:X ⊢ int:Y »»
  ∎ X ⊢ +B +X0 » $X $X
  ∎ B X0 ⊢ Y » #frac_r . #frac_r_b

|
∠ frac_r_b ~ (f ~ ℤ ⊢ ℤ) . ℤ ℤ ⊢ ℤ :=
| 1
| $1,($1 + -1) » $0,(#f $1) » $0*$1

§ @ frac_r : ℤ ⊢ ℤ ≒
  ∠ $0 $0
    |» 1
    |⋔ $1 ¦ ($1 + -1) » #frac_r
        >⋔ &0.$0 * &1.$0

§ @ tarai : ℤ ℤ ℤ ⊢ ℤ ≒
  ⋔ $0 $1 » #le ¦ $.
  >⋔ ∠ $0.$0 $1
    |» $1.$2
    |» ⋔ ($1.$1 + -1) $1.$2 $1.$3 » #tarai
       ¦ ($1.$2 - 1) $1.$3 $1.$1 » #tarai
       ¦ ($1.$3 - 1) $1.$1 $1.$2 » #tarai
       >⋔ $0.$0 $1.$0 $2.$0
       » #tarai

       a b c » #f ∎ #h » #i #j #k

§ @ tarai : ℤ ℤ ℤ ⊢ ℤ ≒
  »! { $0 $1 } ∎
  » ⁅#le⁆ ∎
    |» $1.$1
    |»! { ($1.$1 + -1) $1.$2 $1.$3 } { ($1.$2 + -1) $1.$3 $1.$1 } { ($1.$3 + -1) $1.$1 $1.$2 }
        » #tarai #tarai #tarai
        »! #tarai

§ @ frac : ℤ ⊢ ℤ ≒
  »! ∠$0 $0
    |» 1
    |»! $1 ($1 + -1)
     » ∎ #frac
     »! ($0 * $1)

§ @ frac_i : ℤ ℤ ⊢ ℤ ≒
  »! ∠$0 ∎
    |»! $1.$1
    |»! ($1.$0 + -1) ($1.$0 * $1.$1)
     »! #frac_i
§ frac_r : ℤ ⊢ ℤ ≒
  »! $0 1
  »! #frac_i

|
§ @ tarai : ℤ ℤ ℤ ⊢ ℤ ≒
  »! { $0 $1 } ∎
  » ∠#le ∎
    |» $1.1
    |»! {($1.0 - 1) $1.1 $1.2} {($1.1 - 1) $1.2 $1.0} {($1.2 - 1) $1.0 $1.1}
        » #0 #0 #0
        »! #0


§ @ frac : ℤ ⊢ ℤ ≒
  ! ∠$0 $0
  |! 1
  |! $1 ($1 + -1)
    » ∎ #0
    »! ($0 * $1)

∎ X ⊢ Y » <glb_exp>

˙˙...˙˙˙˙˙..˙˙.˙...
∎±∄∅¶∠∀∏∐ℤ{≒∎∑∃‣‡§«»◂¿±λB‡¦⊢⊣≒∎∑∎±∄∅¶∎±∄∅}
§ dbl : ! list ⊢ ! list ≒ ;
 ! ∠[$] ;
 .| ;
   ! #nil◂{}  ;
   ». ;
 |. ;
   ~ $*2 ». ¦ #dbl◂$ ». ;
   » ! #cns◂$ ;
   ».
§ dbl : ! list ⊢ ! list ≒ ! ∠[$] .| ! #nil◂{} ». |. ~ $*2 ». ¦ #dbl◂$ ». » ! #cns◂$ ».

¶ ∀a ▸ list ≃ ∐ : nil ∐ #a @ : cns
¶ ∀a ▸ opt ≃ ∐ #a : some ∐ : none
¶ ∀a b ▸ cprd ≃ ∐ #a : left ∐ #b : right
¶ ∀a b ▸ tns ≃ #a #b : tns

cprd ◂ ℤ ⊥ : left◂5
∀a ▸ P
∀a ▸ a→a : id

list◂ℤ
list◂{}

A/B B B\C
B/A A/B B B\C

dick:
  | "(" l_prn
  | "(" dick_list l_prn
l_prn:
  | ")"
dick_list:
  | "(" l_prn
  | "(" dick_list l_prn
  | "(" l_prn dick_list
  | "(" dick_list l_prn dick_list

L_PRN ≒ "(" :
  > c0 . r_prn → dick
  > c1 . dick_list → r_prn → dick
  > c2 . r_prn → dick_list
  > c3 . dick_list → r_prn → dick_list
  > c4 . r_prn → dick_list → dick_list
  > c5 . dick_list → r_prn → dick_list → dick_list

L_PRN ≒ "(" :
  > c0 . dick/r_prn
  > c1 . dick/r_prn/dick_list
  > c2 . dick_list/r_prn
  > c3 . dick_list/r_prn/dick_list
  > c4 . dick_list/dick_list/r_prn
  > c5 . dick_list/dick_list/r_prn/dick_list
R_PRN ≒ ")" :
  > r_prn

dick:
  | "(" l_prn
  | l_dick l_prn
  ;
l_dick:
  | "(" dick_list
  ;
l_prn:
  | ")"
prn:
  | "(" l_prn
  ;
dick_list:
  | "(" l_prn
  | l_dick l_prn
  | prn dick_list
  | dick_list_prn dick_list
  ;
dick_list_prn:
  | l_dick l_prn
  ;
  { c0 { { c1 c5 } { c3 c4 }}}

Canon_Form =
  | Atom of string
  | App of { string Canon_Form }
  |
TKN
  > plc0 : c0
  > plc1 : c1
  > plc2 : c2
  ..
  > plcN : cN

0 1 2 3 4 .. n // dependent ℕ[n]

¶ @ ord_list ≃
  > : ord_nil
  > tkn ord_list : ord_cns

¶§ @ dick[L_PRN ¿X] ≃
  > r_prn[¿X]
  > r_prn*dick_list[¿X]
  @ dick_list[L_RPN ¿X] :-
  > r_prn*dick_list[¿X]
  > dick_list*r_prn[¿X]
  > dick_list*r_prn*dick_list[¿X]
  @ r_prn[¿X] :-
  > R_PRN
|
¶ a b ▸ parse ≃ ∐ : fail ∐ b : rtn

¶ prn_tkn ≃
  > : L_PRN
  > : R_PRN
  >.

∠[ <typ> \ <typ> ]  dependent type
  #[ <exp> \ <exp> ] dependent call

¶ ∠[ prn_tkn \ dick] ≃
  \∐ > r_prn : p0
     > r_prn dick_list : p1
     >.
  \∐ >.

¶ exp_tkn ≃ ∐ : MLT ∐ : PLS ∐ ! ℤ : INT
¶ ∠[exp_tkn \ exp]
  ∐ ≃ > exp exp : e0
      >. 0
  ∐ ≃ > exp exp : e1
      >.
  ∐ ≃ > : e2
      >.
ℤ ; integer
ⅅ ; finite number
ℤ[252] ; finite number
ℤ^[10]
ℤ^[0]
¶ d2 ≃ {^ ℤ:x , ℤ:y }

» ! {^ x≒10 , y≒20 }
» ` ℤ^d2  &x &y &x◃$ &y◃$
{< 1 2 3 4 [323] 4 5 6 }
    $◃(-1123)
ℍ ; infinite vector
a ^ [b] ; b indexed array
  a^[10]
  ℍ[¡252z]◂ⅅ[¡2z]
  ℍ[¡0n]◂ℤ
ℍ◂a ≒ a ^ N ;
  ℍ◂(ⅅ[¡2z])
  ℍ◂(ℍ◂(ⅅ[¡2z]))
    ¡0f ¡937248f ¡98324 ¡0f ¡1f ¡0x987324
    ¡234z ¡234n ¡34234r ¡-123c ¡23FG0E34234x
    ¡2342f
∠[ ℤ \ ⅅ ]
` ⅅ[4] ℤ : (32 / 4)

∀[ {} \ r_prn → dick] : p0
  #p0[{}] : r_prn→dick[{}]
¶+ @ dick[L_PRN] ≃
  > r_prn : p0
  > r_prn dick_list : p1
  >.
  @ dick_list[L_RPN] ≃
  > r_prn dick_list : p2
  > dick_list r_prn : p3
  > dick_list r_prn dick_list : p4
  >.
  @ r_prn[R_PRN]
  > : p5
  >.
¶§ @ dick[¿X] ≃
  ∐ fail
  ∐ > r_prn[#0◂¿X]
    > r_prn*dick_list[#0◂¿X]

» & , .. ¦ ..
L_PRN
  > [ dick/r_prn ] : c0
  > [ dick/r_prn/dick_list ] : c1
  > [ dick_list/r_prn ] : c2
  > [ dick_list/r_prn/dick_list ] : c3
  > [ dick_list/dick_list/r_prn ] : c4
  > [ dick_list/dick_list/r_prn/dick_list ] : c5

L_PRN[X0] , R_PRN[X1] , ..

R_PRN ≒ ")" :
TREE ≒
  ∐ tkn0 : atom0
  ∐ tkn1 : atom1
  ∐ tkn2 : atom2
  ∐ TREE TREE : app

L_PRN :
  > r_prn → dick
  > dick_list → r_prn → dick
  >
exp:
  | "x"
  | exp "+" exp
  | exp "*" exp

x * x + x
x + x * x

X + X + X + X + X


X ^
  > exp/pls : %x_pls
  >.
+ ^
  > pls/exp : %pls

X ‡
  > exp/mlt : x_mlt
  > exp : x
  > exp/pls : x_pls
  >.
PLS ‡
  > pls : p0
  >.
MLT
  > mlt : m0
  >.
X PLS X
  ‡‡x_pls·p0·x_pls

¶ ℬ ≅ ∐ ℬ ℬ : ‡ ∐ tkn : atom
exp0:
  | "x"
  | "x" "+" exp

S %  L_PRN < R_PRN < R_PRN < L_PRN < R_PRN

S/B B B\S
A/(B/C) (B/C) C
A C ∐ A/(B/C) B

A/B/C B/C C

∀T ▸ list

A→B:f
list[A]→list[B]:∑f
∀t ▸ ∀A→B:f ▸ t[A]→t[B] : ∑

§ map : ∀A B ▸ (A→B) ⊢ (list[A]→list[B])

λx.x / $

λx0.λx1.λx2.F(x0,x1,x2) / F($'',$',$)

.» ℤ { ℤ ℤ ℤ ℤ } {} (_→_) : 0 $◃3 {} %0 |
  %0 ≒
    .» $' $ %1 |
      %1 ≒
        .» $''◃2 $ $ $'
        » $'' $
        ».
    ».
» $ $
».

.» 1 4 $
»
  ~ ioj
  » oief
  » oife

  ¦ uf
  » ef

  ¦ fei
  ~.
» sd e
».

∑A B ▸

∀a▸pred[a]

S[X] ≒ P0[X] > P1[X] > .. Pn[X] >.


parsing = code
parsing program

$ (= entire string for parsing)

∀x.P◂x ⊣ ∀x.Q◂x ≒
  fds
  « sd
  « fds
  «.

asyncronous communication
queue is linear
v0 , v1 , v2 , v3 = v0+v1+v2+v3v4


nested module is nonsense

Node Edge Node
N E N
N (E N E) N
E -> E N E
N -> N E N
  N
» N E N
» N (E N E) N

btree =
  | : Leaf
  | ¬btree ¬btree : BTree

  node ¬node
`¿a ¿b

module
§§ <module-parameter> ▸ <module-name> ≒
  ¶ <flow-def>
  ..
  ¶.
  § <global-entry>
  ..
  §.
§§.
module concatenation
§§ <pre-module> > <post-module> ≒
..
§§.
glueing module
§§ #0 .. #n , ▸ <module-name> |
  #0 ≒ §§ ..
    §§.
  ≒
§§.
¶ bin ≃ .% y n %.
  %y %n (%y+%n)
¶ f5 ≃ .% a0 a1 a2 a3 a4 %.
¶ f7 ≃ .% a7_0 a7_1 a7_2 a7_3 a7_4 a7_5 a7_6 %.

¶ abc ≃ ∐ : a ∐ : b ∐ : c
¶ ∠[abc \ dep_abc] ≒
  \∐ ≃ ∐ ℤ : a_c0 ∐ ℤ ℤ : a_c1
  \∐ ≃ opn◂ℤ : b_c0
  \∐ ≃ lst◂ℤ : c_c0
  dep_abc[a◂{}]
¶ ∠[ !ℤ \ dep0_Z ] ≒
  « dep1_Z[$+$*2] dep2_Z[$+10] : q0
linked data , dependent type
¶  ∠[?v \ node]
  ∐ ≃
  ∐ ≃
¶ ∠[ ! ℕ \ a▸dep_lst ] ≒
  \∐ ≃ ∐ : dep_nil
  \∐ ≃ ∐ a dep_lst[$]◂a : dep_cns
∇∇∆∆⏫⏬⇋⇋⇒⇒⇓⇓
⸢⸢⸖⸖⸖><

∀class_name ?val \ type-exp

∀Z ?t \ { ?t ?t } → ?t : (+)
∀Type ?t \ ?t → ?t : #id
∀Type ?a \ ∀Type ?b \ list◂?a → list◂?b : #map

naming is used just for subtyping

{^ ℤ:&x , ℤ:&y, ℤ:&z }‹›⁅⁆⁅ f t ⁆
  &x◃$

  {^ {^ $ +> &a≒hoge , &b≒foo } +>
¶ ∀type ?a \ ⁅?a⁆ ≃ ∐ : #none ∐ ?a : #some
%% #none ⁅⁆
%% #some◂x ⁅x⁆

¶　p0 ≃ ∐^Code : ℤ
¶ p0 +> p1 ≃ ∐^Text : p0 ℤ
¶ p0 +> p2 ≃ ∐^Foo : ℤ ℤ ℤ
¶ r0 ≃ {^ ℤ:&x , ℤ:&y }
¶ r0 +> r1 ≃ {^ ℤ:&z }
¶ r1 +> r2 ≃ {^ ℤ:&t }

¶ f5 ≃ .% k0 k1 k2 k3 k4
¶ bin ≃ .% y n
  %y %n
{^ {^ {^ +> &x≒4 , &y≒9 } +> &z≒-32 } +> &t≒192 }
&x◃$
&x^$ &y^$
{^ {^ +> &x≒4 , &y≒"z" } +> &x≒5 }
∐^Code
∐^Text
+>
∐^Exp
+>

map
∠[ map \ net]
?v◃(net[?m])

¶ ∀Type ?t \ val ≃ {^ ?t:&val }
¶ flag◂?f ≃ {^ val◂?t +> ?f:&flag }

⁅|v|⁆ {^ &val≒v }

hidden parameter
ℕ ; type
ℕ |+> ℤ:?f ; type plus hidden parameter≤
$^10 $^1^3^4  $^2 $^3 $^x $^y  $^(-34)
{' { 4 "test" $ { $ $ }} <+ $^1≒10 , $^2≒3 }


{^0^2 { $ 3 "ted" } ≒ $+$ }
{ $ 3 2 } ≒^0^2 $*$+1
! ($ ≒^0^3 { $ $ })

option product  $◃3 $◃2
  ?a→{ ?b0 ?b1 ?b2 .. ?bn } → ?a
  {(?a→‹?b0›) (?a→‹?b1›)} → (?a→‹{?b0 ?b1}›) : ‹*›
  {‹?b0› ‹?b1›} → ‹{?b0 ?b1}› : ‹*›

(∀^Z?a\?a→?a)

‹› ‹*› ⊥ = ‹›
⊥ ‹*› ‹› = ‹›
‹a› ‹*› ‹b› = ‹{a b}›

{ ‹?a0› ‹?a1› .. ‹?an› } → ‹{ ?a0 ?a1 ?a2 .. ?an }› : ‹**›
⁅⁆
¶ nat ≃ ∐ ‹nat› : S
f0 ≒ ∐^#zero◂{} ‹›
     ∐^#succ◂x ‹#succ◂(f1◂x)›
f1 ≒ ∐^#zero◂{}
#S◂‹› #S◂‹#S◂‹››

» ` Hoe : O ioe ¡$ $ eif >| ` Nnie : ¡$◃3 $◃1 oije3 984
» $ $ <|
parser◂?a ≃
  ∐ token→parser : ctn
  ∐ : fail
  ∐ ?a : rtn

nd_parser◂?a ≃
  ∐ token→⟦nd_parser⟧ : nd_ctn
  ∐ ?a : nd_rtn

¶ tkn ≃ ∐ : PLS ∐ : MLT ∐ ℤ : INT
§ exp : ⊢ nd_parser◂tkn ≒
  #0 |
  #0 ≒
    .» ∠[$]
      .∐ #0◂$
       ∐
    ∇ $ $
    ».

∠[tkn \ entry0] ≃
  \∐
land→(map→address)→(value→?a)→?a :
land (map→{address address}) ⊢ land : subst

#∐[3]◂"test" `: ∐[ ∅ ∅ ∅ srg ]
.» ∠[$]
  ∐ $◃0 $◃1
  ∐ $+4 $
∇.
`: ∐[ {ℤ \ℤ[?z]} \ℤ[?z] ] → {ℤ \ℤ[?z]}
    %y + %n//
    23 + %n//
    456// * %y
    345n +n 234n *n 3n
∀^ℤ ?z \ {?z ?z}→?z

base◂?a ; types of base object
base◂{} ;
base◂⟦q⟧
a∀ base◂a'→string : method0
base◂?a → t1 : method1

base◂{?a ?b} ; type of sub object
base◂{?a ?b} → t2 : method2

$'  a'  a. a'
state |> hyper state  ; open hyper state
state <| ; close hyper state
  x ‹»› f
  f‹◂›x
‹^ `t0:x0 , `t1:x1 ›
  ∐[> `tx:x0 , `ty:y ]
  #∐^x◂{}

.» fe
» oijef
  ⁅ hoiewf » oijef » oief

  ¦ oie » joief » oief

  ¦ oiejf oi » ef
⁆ ioef
» oijef
».

oif » oij oij ∠[ief] .∇
  ∐ oijef
  ∐ oijef
∇.

» oiewfoie i oi oef ∠[ef] ef .∆
  ∏
  ∏
∆.

`t0:`t1:v ; subtyping
.» f » ewr ».
.« oiefj « eif «.

binary type tree
obj◂{a' b'}
obj◂{win◂{a' b'} c'}
win◂(vbox◂{hbox◂{scroll◂text null} image})
< x y .. > < x y 'z >


#macro def_word word
#macro stack list
== word0 word1 word2 word3 word4

» iojf ioj ∠[fe] fe .∇
  ∐
  ∐
∇.
== string 文字列 text buffer binary file ==.

channel space > window space
root window

sgn ; signature type
`{}→sgn:sgn ; create signature
sgn◂{}

¶ cpnt ≃
  ∐ pt_cpnt charge pt_cpnt : CHARGE
  ∐ pt_cpnt rgst pt_cpnt : WIRE
  ∐ pt_cpnt pt_cpnt : NOT
  ∐ {pt_cpnt pt_cpnt} pt_cpnt : AND
  ∐ pt_cpnt {pt_cpnt pt_cpnt} : OR

¶ pt_cpnt == sgn
¶ cct == cpnt‹^›pt_cpnt

= ; eq
a' ^ ℤ ; vector
a' ^ bin

a' ‹^› b' ; option vector type
a' ‹^› sgn ;
== a' | (ref[a']) (a' ‹^› sgn) ==.


a b c ~+ {^ t0:?a,t1:?b } ⊢ hoefe ~+ {^ .. } ; alternate place , object

» &< ?a v
» $ 2 3 (>&+1)
» !< a b c ~+ {^ ?a≒?x,?b≒?y } > proc

» +&[2] ?c w

.» oiefo
» opk
∇ oiejf ∠[fd] fef
  ∐ oief j
  » ijf
  » ij
  ».
  ∐ iojf
  » i i ie oj
    ⁅ oijds » oije » jio ».
    ¦ i » ij ».
    ¦ ».
    ¦ $ $ ».
  ⁆^∇ ioj ∠[oij] ij
    ∐ ij ».
    ∐. ief » ij ».
    ∇^»
  ∐
  »
  ».
∇< oijef
».

» foiefj
.∆ feoi f
  ∏
  ∏
  ∏
∆.

& `: {}→sgn
&' `: a∀ {}→psg◂a'
snd `: a∀ {(psg◂a') a'}→{}
cnt `: s∀ a∀ {(psg◂a') s' ({a' s'}→‹s'›)}→{}
rcv `: r∀ s∀ a∀ {(psg◂a') s' ({a' s'}→(co_prd◂{s' r'}))}→r'
(++) `: [`a:r]∀
== (ref◂n') , (n' ‹^› sgn)
== yes , y , Y , Yes
== no , No , N , n

» $ oief ? { $ $+3 }
  |»
  »
  »
»| `(x→y) :


external input output
コマンドとして実装
rungui -f impl.mdls Impl


§ fib ≒
	.» r _ ⊵ $ ∠[$]
		∐ !0 ».
		∐ r _ ⊵ r ∠[$◃0 + -1]
			∐ !1 ».
			∐ ! (fib◂($◃0 + -1)) + (fib◂($◃0 + -2)) ».
		∇
	∇

.» $ oije woi
  |» $+3 $' $ $'+$
  » $+$
    |» $ hd◂$'
    » ioj
    ».
  ∎^» oij
  »
  ».
∎

¶ t◂{a' b'} == {a' a' b' b'}
